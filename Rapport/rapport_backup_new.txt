\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{fancyhdr}
\usepackage{geometry}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[french]{babel}

\begin{document}

\setlength{\marginparwidth}{0pt}
\setlength{\marginparsep}{0pt}

\pagestyle{fancy}
\renewcommand\headrulewidth{1pt}
\fancyhead[L]{\includegraphics[scale=0.22]{logo_uvsq.jpeg}}
\fancyhead[R]{22 décembre 2023}

\hspace{10cm}

\begin{center}
        
    \huge
    Projet de Programmation Numérique
    \vspace{2.0cm}

    \huge 
    \textbf {ARRONDI STOCHASTIQUE POUR LE CALCUL SCIENTIFIQUE} \\

    \vspace{1.0cm}

    \normalsize
    Par Yizhi Yang, Chun Qi, Yutai Zhao et Lisa Taldir \\ Sous l'encadrement de Pablo Oliveira, El Medhi El Arar et Devan Sohier \\ 
       
\end{center}
    
\vspace{1cm}

\tableofcontents

\newpage

\section{Introduction}

Bien que des machines permettant de réaliser des calculs de plus en plus complexes se développent, la taille de la mantisse reste limitée, et donc bien souvent le résultat ces calculs doit être arrondi. Alors comment faire le meilleur choix d'arrondi ? \\

Pour répondre à cette question, nous nous interesserons ici à l'arrondi stochastique et nous comparerons ses résultats avec ceux de l’arrondi déterministe au plus près, pour différents algorithmes d'exponentiations : une version naîve et une version rapide.


\subsection{Arrondi déterministe au plus près}

L'IEEE 754 est un standard qui définit le format de la représentation des nombres flottants sous forme binaire. il spécifie en plus les règles pour les opérations arithmétiques en gérant par exemple les arrondis pendant les operations, afin de garantir une certaine précision du résultat qui ne peut pas etre représenté de manière exacte.\\

L’arrondi déterministe au plus près est l'une des méthodes d'arrondi spécifiées par ce standard, il choisit le flottant représentable le plus proche du résultat. Par exemple, le nombre 0.56 se voit arrondi à 0.6. C'est l'arrondi choisit par défaut.

\subsection{Arrondi stochastique}

l'arrondi stochastique, quant a lui, au lieu d'arrondir toujours vers le haut ou vers le bas selon des règles déterministes, l'arrondi stochastique utilise une approche probabiliste où la décision d'arrondir est prise avec une certaine probabilité.\\

Le principe de l'arrondi stochastique est le suivant : soit x la valeur exacte et fl(x) sa valeur approchée, on pose fl(x) = $\lfloor x \rfloor$ avec une probabilité de p et $\lceil x \rceil$ avec une probabilité de 1-p où \\ p = $\frac{\lceil x \rceil - x}{\lceil x \rceil - \lfloor x \rfloor}$. \\


Il est alors interessant de remarquer que 
\begin{center}
    $\mathbb{E}[fl(x)]$ = $\lfloor x \rfloor \times p$ + $\lceil x \rceil \times (1-p)$ = $x$
\end{center}
Ainsi, cet arrondi permet en moyenne de retomber sur la valeur exacte x.\\


\begin{center}
  \textbf{Nous noterons dans la suit x la valeur exacte et fl(x) la valeur flottante après l'arrondi.}
\end{center}


\section{Étude de l'algorithme d'exponentiation}

Dans cette partie, nous etudierons les erreurs d'arrondi de 2 algo commises lors du calcul.

Posons le resultat de l'operation $x \circ y$ : \[ \text{fl}(x \circ y) = (x \circ y)(1 + \mu) \]

Avec \(|\mu| \leq u = 2^{-53}\)


\subsection{Algorithme naif}

Montrons que pour l'algorithme d'exponentiation naif, on a $\mathbb{E}[fl(x^{n})] = x^{n}$ pour tout $n \in \mathbb{N}$.

\begin{align*}
\text{fl}(x^2) &= x^2 \cdot (1 + \delta_1) \\
\text{fl}(x^3) &= x \cdot \text{fl}(x^2) \cdot (1+ \delta_2) \\
              &= x \cdot x^2 \cdot (1+\delta_1) \cdot (1+\delta_2) \\
              &= x^3 \cdot (1+\delta_1) \cdot (1+\delta_2) \\
\implies \text{fl}(x^n) &= x^n \cdot \prod_{i=1}^{n-1}(1+ \delta_i) \\
Cov(\delta_i, \delta_j) &= \mathbb{E}[(\delta_i - \mathbb{E}[\delta_i]) \cdot (\delta_j - \mathbb{E}[\delta_j])] \\
&= \mathbb{E}[\delta_i\delta_j - \delta_j\mathbb{E}[\delta_i]-\delta_i\mathbb{E}[\delta_j]+\mathbb{E}[\delta_i]\mathbb{E}[\delta_j]] \\
&= \mathbb{E}[\delta_i\delta_j] - \mathbb{E}[\delta_j\mathbb{E}[\delta_i]]-\mathbb{E}[\delta_i\mathbb{E}[\delta_j]]+\mathbb{E}[\mathbb{E}[\delta_i]\mathbb{E}[\delta_j]] \\
&= \mathbb{E}[\delta_i\delta_j] - \mathbb{E}[\delta_i]\mathbb{E}[\delta_j]-\mathbb{E}[\delta_j]\mathbb{E}[\delta_i]+\mathbb{E}[\delta_i]\mathbb{E}[\delta_j] \\
&= \mathbb{E}[\delta_i\delta_j] - \mathbb{E}[\delta_i]\mathbb{E}[\delta_j]\\
&= 0\\
\end{align*}
Calculons son esperance : 
$$\mathbb{E}[\text{fl}(x^n)] = \mathbb{E}[x^n \cdot \prod_{i=1}^{n-1}(1+ \delta_i)] $$
Par linearite de l'esperance : 
$$\mathbb{E}[\text{fl}(x^n)]=\mathbb{E}[x^n] \cdot \mathbb{E}[\prod_{i=1}^{n-1}(1+ \delta_i)]$$
car $ x^n $ est une constante :
$$\mathbb{E}[\text{fl}(x^n)]=x^n \cdot \mathbb{E}[\prod_{i=1}^{n-1}(1+ \delta_i)]$$
Par non-correlation des $delta$ : 
\begin{align*}
\mathbb{E}[\text{fl}(x^n)] &= x^n \cdot \prod_{i=1}^{n-1} \mathbb{E}([ (1+\delta_i)])\\
&= x^n \cdot \prod_{i=1}^{n-1} (\mathbb{E}[1]+\mathbb{E}[ \delta_i ])\\
&= x^n \cdot \prod_{i=1}^{n-1} (1+0)\\
&= x^n \\
\end{align*}

\subsection{Algorithme rapide}

Transfomons d'abord l'exposant $n$ en representation binaire et stockons chaque bit $x_{i}$. Nous avons ainsi :
\\
\begin{align*}
  \begin{cases}
    n = 2^{n-1}x_{1} + 2^{n-2}x_{2} + ... + x_{n-1} \\
    \forall i \in [0,n],  x_i \in \{0,1\} \\
  \end{cases}
\end{align*}
\\
\\
Posons ensuite la somme $U_i = \sum_{k=i+1}^{n} 2^{n-k}x_k$ et $r \in \mathbb{N}$ valant le nombre de 1 dans la representation binaire de $n$
\\
\\
Nous pouvons remarquer que (à demontrer par recurrence ?) : 
$$fl(x^n) = x^n \cdot \prod_{i=1}^{n-1} (1+\delta_i)^{U_i} \cdot \prod_{i=n}^{n+r-1} (1+\delta_i) $$
Calculons son esperance : 
$$\mathbb{E}[fl(x^{n})] = \mathbb{E}[x^n \cdot \prod_{i=1}^{n-1} (1+\delta_i)^{U_i} \cdot \prod_{i=n}^{n+r-1} (1+\delta_i)] $$
Par linearite de l'esperance : 
$$\mathbb{E}[fl(x^{n})] = x^n \cdot \mathbb{E}[ \prod_{i=1}^{n-1} (1+\delta_i)^{U_i} \cdot \prod_{i=n}^{n+r-1} (1+\delta_i)] $$
Par non-correlation des $delta$ : 
\begin{align*}
\mathbb{E}[fl(x^{n})] &= x^n \cdot \prod_{i=1}^{n-1} \mathbb{E}[ (1+\delta_i)]^{U_i} \cdot \prod_{i=n}^{n+r-1} \mathbb{E}[(1+\delta_i)] \\
&= x^n \cdot \prod_{i=1}^{n-1} (\mathbb{E}[1]+\mathbb{E}[\delta_i])^{U_i} \cdot \prod_{i=n}^{n+r-1} (\mathbb{E}[1]+\mathbb{E}[\delta_i]) \\
 &= x^n \cdot  \prod_{i=1}^{n-1} (1)^{U_i} \cdot \prod_{i=n}^{n+r-1} (1) \\
 &= x^n 
\end{align*}

\section{Implémentation et graphiques obtenus}
\subsection{Tests unitaires}
Tout au début de l'implémentation, on lance des tests unitaires pour chaque algorithme : méthodes naïves récursives/intératives et rapides récursives/intératives.
\\
\\

Au lieu de choisir la fonction test d'égalité 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\begin{lstlisting}[language=C++]
EXPECT_EQ(expected_value, actual_value);
\end{lstlisting}
on applique une autre fonction de Google Test comme la suivante :

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{lstlisting}[language=C++, caption=Unit test (extract)]
double r = 1.0E-13;
TEST(ExpNaifRec, BasicTest) 
{
    EXPECT_NEAR(exp_naif_rec(18.9, 6), 45579633.110361, 45579633.110361 * r); 
    EXPECT_NEAR(exp_naif_rec(18.9, 50), 6.6541135651775104E+63, 6.6541135651775104E+63 * r);
    EXPECT_NEAR(exp_naif_rec(18.9, 100), 4.4277227338279358E+127, 4.4277227338279358E+127 * r);

    EXPECT_NEAR(exp_naif_rec(111.11, 8), 23228714744613045.0, 23228714744613045.0 * r);

    EXPECT_NEAR(exp_naif_rec(6543.2, 32), 1.2743427304864022E+122, 1.2743427304864022E+122 * r);
}
\end{lstlisting}
Ici, on définit un taux de tolérence $r = 1.0 \times 10^{-13}$ pour comparer si les deux valeurs obtenues de notre algorithme et de Python sont assez proches l'une et l'autre. On prévoit bien une inégalité car c'est exactement les erreurs d'arrondi auxquelles on s'intéresse.
\\
\\
Afin d'améliorer la couverture de test, on parcourt les quatre méthodes par groupes de valeurs à tester; dans chaque groupe, on fixe d'abord une petite base et modifie l'exposant de petite valeur à grande valeur. Ensuite, on répète le même processus en augmantant la base tout juste avant d'atteindre la "capacité limite".
\\
\\
Les tests réussissent car aucune erreur relative dépasse le taux de tolérence. Cela signifie que nos algorithmes sont validés au sens de mathématiques.
\\
\\
On s'intéresse maintenant à l'étude des erreurs d'arrondi.

\subsection{Algorithme naif}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{lstlisting}[language=C, caption=Naif recursif]
double exp_rapid_iter(double x, int n)
{
    if(n == 0) {
        return 1;
    }
    return x*exp_naif_recursif(x, n-1);
}
\end{lstlisting}

\begin{lstlisting}[language=C, caption=Naif iteratif]
double exp_rapid_iter(double x, int n){
    double r = 1;
    for(int i = 0; i < n; i++){
        r = r*x;
    }
    return r;
}
\end{lstlisting}

\begin{figure}[!h]
    \includegraphics[scale=0.5]{SR_x_2_log.png}
    \caption{texte de la légende}
\end{figure}

\includegraphics[scale=0.75]{SR_x_rand_log.png}

\includegraphics[scale=0.75]{UR_x_rand_log.png}

\subsection{Algorithme rapide}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{lstlisting}[language=C, caption=Rapide reccursif]
double exp_rapid_rec(double x, int n)
{
    double r = 0;
    if(n == 0)
        r = 1;
    else if(n == 1)
        r = x;
    else if(n % 2 == 0)
        r = exp_rapid_rec(x, n/2) * exp_rapid_rec(x, n/2);
    else
        r = x * exp_rapid_rec(x, n/2) * exp_rapid_rec(x, n/2);
    return r;
}
\end{lstlisting}

\begin{lstlisting}[language=C, caption=Rapide iteratif]
double exp_rapid_iter(double x, int n){
    double r=1;
    while(n!=0){ 
        if((n&1)==1){ //n%2 == 1
            r = r*x;
        }
        x =x*x;
        n = n >> 1; //n = n/2
    }
    return r;
}
\end{lstlisting}

\section{Interprétation et analyse}
(on essaye d'expliquer pourquoi on aurait les erreurs de telle allure et les facteurs d'influences, et/ou hypothèse d'indépendance pas vraie etc ...)


\section{Evaluation de performance}

Nous nous interressons enfin à savoir si la version rapide est plus "rapide" que la version de base.\\


\section{Conclusion}
(pour aller plus loin, on pourait faire d'autres expériences, proposer d'autres hypothèses, d'autres possibilité selon les docs etc ...)

\section{Annexes}
(on met ce qu'on a lu ...)

\end{document}
